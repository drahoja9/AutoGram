<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>backend.XMLConverter &mdash; AutoGram  documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="AutoGram  documentation" href="../../index.html" />
    <link rel="up" title="backend" href="../backend.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for backend.XMLConverter</h1><div class="highlight"><pre>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">as</span> <span class="nn">ET</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">ObjectTypes</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">AlgorithmTypes</span>

<span class="n">XML_VERSION</span> <span class="o">=</span> <span class="s1">&#39;&lt;?xml version=&quot;1.0&quot;?&gt;&#39;</span>


<div class="viewcode-block" id="JSONDecodeError"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.JSONDecodeError">[docs]</a><span class="k">class</span> <span class="nc">JSONDecodeError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Base exception class, raised when an error occurs while processing JSON</span>

<span class="sd">    :param msg: message describing the error</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span></div>


<div class="viewcode-block" id="XMLDecodeError"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.XMLDecodeError">[docs]</a><span class="k">class</span> <span class="nc">XMLDecodeError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Base exception class, raised when an error occurs while processing XML</span>

<span class="sd">    :param msg: message describing the error</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span></div>

<span class="c1"># ----------------------------------------------------------------------------------------------------------------------</span>


<div class="viewcode-block" id="JtXConverter"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.JtXConverter">[docs]</a><span class="k">class</span> <span class="nc">JtXConverter</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Base class responsible for converting dictionary representation of a JSON structure</span>
<span class="sd">    to a string representation of an XML structure.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_list_subelements</span><span class="p">(</span><span class="n">parent_element</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">children_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Creates and attaches a simple list of sub elements to a given parent element,</span>
<span class="sd">        all of them with the same specified tag and with the text attribute given in the input list.</span>

<span class="sd">        :param parent_element: the element, that created sub elements should be attached to</span>
<span class="sd">        :param children_list: list of string values to be used as text attributes of the new sub elements</span>
<span class="sd">        :param tag: string value that should be used as a name of the xml tag</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children_list</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent_element</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
            <span class="n">n</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">child</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_single_subelement</span><span class="p">(</span><span class="n">parent_element</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Creates and attaches a single sub element to a given parent element,</span>
<span class="sd">        new element is created with a given tag and given text.</span>

<span class="sd">        :param parent_element: the element that created sub elements should be attached to</span>
<span class="sd">        :param child: string value to be used as text attribute of the new sub elements</span>
<span class="sd">        :param tag: string value that should be used as a name of the xml tag</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent_element</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
        <span class="n">n</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">child</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_fa_transitions</span><span class="p">(</span><span class="n">parent_element</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">children_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Creates and attaches list of transitions to a given parent element</span>

<span class="sd">        :param parent_element: the element, that created sub elements should be attached to</span>
<span class="sd">        :param children_list: list of transitions in format {&#39;from&#39;: &#39;&#39;, &#39;input&#39;: &#39;&#39;, &#39;to&#39;: &#39;&#39;}</span>

<span class="sd">        :raises KeyError: when JSON dict has wrong structure of transitions</span>
<span class="sd">        :raises TypeError: when there are wrong types of values in JSON dict (input is not Character)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">transition</span> <span class="ow">in</span> <span class="n">children_list</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent_element</span><span class="p">,</span> <span class="s1">&#39;transition&#39;</span><span class="p">)</span>

            <span class="n">t_from</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;from&#39;</span><span class="p">)</span>
            <span class="n">t_from_in</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t_from</span><span class="p">,</span> <span class="s1">&#39;String&#39;</span><span class="p">)</span>
            <span class="n">t_from_in</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">transition</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">]</span>

            <span class="n">t_input</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;input&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">transition</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]:</span>
                <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t_input</span><span class="p">,</span> <span class="s1">&#39;epsilon&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t_input_in</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t_input</span><span class="p">,</span> <span class="s1">&#39;Character&#39;</span><span class="p">)</span>
                <span class="n">t_input_in</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">transition</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]))</span>

            <span class="n">t_to</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">)</span>
            <span class="n">t_to_in</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t_to</span><span class="p">,</span> <span class="s1">&#39;String&#39;</span><span class="p">)</span>
            <span class="n">t_to_in</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">transition</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_pda_transitions</span><span class="p">(</span><span class="n">parent_element</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">children_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Creates and attaches list of pushdown store transitions to a given parent element</span>

<span class="sd">        :param parent_element: the element, that created sub elements should be attached to</span>
<span class="sd">        :param children_list: list of transitions in format {&#39;from&#39;: &#39;&#39;, &#39;input&#39;: &#39;&#39;, pop: [&#39;&#39;], &#39;to&#39;: &#39;&#39;, push:[&#39;&#39;]}</span>

<span class="sd">        :raises KeyError: when JSON dict has wrong structure of transitions</span>
<span class="sd">        :raises TypeError: when there are wrong types of values in JSON dict (input, pop and push must be Characters), \</span>
<span class="sd">        or when JSON dict has wrong structure of transitions</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">transition</span> <span class="ow">in</span> <span class="n">children_list</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent_element</span><span class="p">,</span> <span class="s1">&#39;transition&#39;</span><span class="p">)</span>

            <span class="n">t_from</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;from&#39;</span><span class="p">)</span>
            <span class="n">t_from_in</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t_from</span><span class="p">,</span> <span class="s1">&#39;String&#39;</span><span class="p">)</span>
            <span class="n">t_from_in</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">transition</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">]</span>

            <span class="n">t_input</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;input&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">transition</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]:</span>
                <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t_input</span><span class="p">,</span> <span class="s1">&#39;epsilon&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t_input_in</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t_input</span><span class="p">,</span> <span class="s1">&#39;Character&#39;</span><span class="p">)</span>
                <span class="n">t_input_in</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">transition</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]))</span>

            <span class="n">t_pop</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;pop&#39;</span><span class="p">)</span>
            <span class="n">children_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">transition</span><span class="p">[</span><span class="s1">&#39;pop&#39;</span><span class="p">]]</span>
            <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">t_pop</span><span class="p">,</span> <span class="n">children_list</span><span class="p">,</span> <span class="s1">&#39;Character&#39;</span><span class="p">)</span>

            <span class="n">t_to</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">)</span>
            <span class="n">t_to_in</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t_to</span><span class="p">,</span> <span class="s1">&#39;String&#39;</span><span class="p">)</span>
            <span class="n">t_to_in</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">transition</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">]</span>

            <span class="n">t_push</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;push&#39;</span><span class="p">)</span>
            <span class="n">children_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">transition</span><span class="p">[</span><span class="s1">&#39;push&#39;</span><span class="p">]]</span>
            <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">t_push</span><span class="p">,</span> <span class="n">children_list</span><span class="p">,</span> <span class="s1">&#39;Character&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_grammar_rules</span><span class="p">(</span><span class="n">parent_element</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">children_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">nonterminal_alphabet</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">allow_epsilon</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">initial_symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Creates and attaches list of rules to a given parent element</span>

<span class="sd">        :param parent_element: the element, that created sub elements should be attached to</span>
<span class="sd">        :param children_list: list of rules in format like {&#39;from&#39;: &#39;&#39;, &#39;to&#39;: [&#39;&#39;, &#39;&#39;]}</span>
<span class="sd">        :param nonterminal_alphabet: list of symbols to be tagged as &quot;Strings&quot;, other will be tagged as &quot;Character&quot;</span>
<span class="sd">        :param allow_epsilon: boolean value, true if rule &quot;rewrite initial symbol to epsilon&quot; should be allowed to be \</span>
<span class="sd">        in XML, false otherwise</span>
<span class="sd">        :param initial_symbol: initial symbol of grammar</span>

<span class="sd">        :raises KeyError: when JSON dict has wrong structure of grammar rules</span>
<span class="sd">        :raises TypeError: when there are wrong types of values in JSON dict (terminal symbols must be Characters), \</span>
<span class="sd">        or when JSON dict has wrong structure of grammar rules</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">children_list</span><span class="p">:</span>
            <span class="c1"># skip epsilon at initial symbol</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_epsilon</span> <span class="ow">and</span> <span class="n">rule</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;from&#39;</span><span class="p">:</span> <span class="n">initial_symbol</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">:</span> <span class="p">[</span><span class="bp">None</span><span class="p">]}:</span>
                <span class="k">continue</span>
            <span class="c1"># continue normally</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent_element</span><span class="p">,</span> <span class="s1">&#39;rule&#39;</span><span class="p">)</span>
            <span class="n">r_l</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;lhs&#39;</span><span class="p">)</span>
            <span class="n">r_l_in</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">r_l</span><span class="p">,</span> <span class="s2">&quot;String&quot;</span><span class="p">)</span>
            <span class="n">r_l_in</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">]</span>

            <span class="n">r_r</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;rhs&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">symbol</span><span class="p">:</span>
                    <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">r_r</span><span class="p">,</span> <span class="s2">&quot;epsilon&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">nonterminal_alphabet</span><span class="p">:</span>
                    <span class="n">r_r_in</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">r_r</span><span class="p">,</span> <span class="s2">&quot;String&quot;</span><span class="p">)</span>
                    <span class="n">r_r_in</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">symbol</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">r_r_in</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">r_r</span><span class="p">,</span> <span class="s2">&quot;Character&quot;</span><span class="p">)</span>
                    <span class="n">r_r_in</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">symbol</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_grammar_generates_epsilon</span><span class="p">(</span><span class="n">parent_element</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">rule_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">initial_symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Transforms grammar to the type accepted by library - adds value to generatesEpsilon tag, \</span>
<span class="sd">        true if the rule &quot;rewrite initial symbol to epsilon&quot; was present in the original grammar</span>

<span class="sd">        :param parent_element: allready created generatesEpsilon tag</span>
<span class="sd">        :param rule_list: rule list of grammar</span>
<span class="sd">        :param initial_symbol: initial symbol of grammar</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">null_rule</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;from&#39;</span><span class="p">:</span> <span class="n">initial_symbol</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">:</span> <span class="p">[</span><span class="bp">None</span><span class="p">]}</span>
        <span class="k">if</span> <span class="n">null_rule</span> <span class="ow">in</span> <span class="n">rule_list</span><span class="p">:</span>
            <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent_element</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent_element</span><span class="p">,</span> <span class="s1">&#39;false&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_regexp_value</span><span class="p">(</span><span class="n">parent_element</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">value_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Creates and attaches regexp value part to a given parent element,</span>
<span class="sd">        is supposed to be called recursively</span>

<span class="sd">        :param parent_element: element, that the value should be attached to</span>
<span class="sd">        :param value_dict: dictionary describing the value in format like {type: &#39;&#39;, value: &#39;&#39;}</span>

<span class="sd">        :raises KeyError: when JSON dict has wrong structure of regexp value</span>
<span class="sd">        :raises TypeError: when there are wrong types of values in JSON dict (alphabet symbols must be Characters), \</span>
<span class="sd">        or when JSON dict has wrong structure of regexp value or when there is unknown type value</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_type</span> <span class="o">=</span> <span class="n">value_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s1">&#39;term&#39;</span><span class="p">:</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent_element</span><span class="p">,</span> <span class="s1">&#39;Character&#39;</span><span class="p">)</span>
            <span class="n">sub</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">value_dict</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s1">&#39;epsilon&#39;</span><span class="p">:</span>
            <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent_element</span><span class="p">,</span> <span class="s1">&#39;epsilon&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s1">&#39;empty_symbol&#39;</span><span class="p">:</span>
            <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent_element</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s1">&#39;iteration&#39;</span><span class="p">:</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent_element</span><span class="p">,</span> <span class="s1">&#39;iteration&#39;</span><span class="p">)</span>
            <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_regexp_value</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">value_dict</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s1">&#39;concatenation&#39;</span> <span class="ow">or</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s1">&#39;alternation&#39;</span><span class="p">:</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">parent_element</span><span class="p">,</span> <span class="n">node_type</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">dct</span> <span class="ow">in</span> <span class="n">value_dict</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]:</span>
                <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_regexp_value</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_json_to_xml_fa</span><span class="p">(</span><span class="n">json_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Responsible for converting dictionaries representing finite automata (DFA, NFA) to XML files</span>

<span class="sd">        :param json_dict: dictionary representation of a JSON structure describing finite automaton</span>

<span class="sd">        :return: string representation of an XML file describing given finite automaton</span>

<span class="sd">        :raises KeyError: when JSON dict has wrong structure</span>
<span class="sd">        :raises TypeError: when there are wrong types of values in JSON dict (input symbols must be Characters), \</span>
<span class="sd">        or when JSON dict has wrong structure or when there is bad combination of automaton type and properties</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">multi</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">a_type</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;initial_states&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">a_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">NFA</span><span class="p">:</span>
            <span class="n">etree_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="n">ObjectTypes</span><span class="o">.</span><span class="n">MultiNFA</span><span class="p">)</span>
            <span class="n">multi</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;initial_states&#39;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">a_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">NFA</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">etree_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="n">a_type</span><span class="p">)</span>

        <span class="n">states</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;states&#39;</span><span class="p">)</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">],</span> <span class="s2">&quot;String&quot;</span><span class="p">)</span>

        <span class="n">input_alphabet</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;inputAlphabet&#39;</span><span class="p">)</span>
        <span class="n">children_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;input_alphabet&#39;</span><span class="p">]]</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">children_list</span><span class="p">,</span> <span class="s2">&quot;Character&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">multi</span><span class="p">:</span>
            <span class="n">initial_states</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;initialStates&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initial_states</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;initialState&#39;</span><span class="p">)</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">initial_states</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;initial_states&#39;</span><span class="p">],</span> <span class="s2">&quot;String&quot;</span><span class="p">)</span>

        <span class="n">final_states</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;finalStates&#39;</span><span class="p">)</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">final_states</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;final_states&#39;</span><span class="p">],</span> <span class="s2">&quot;String&quot;</span><span class="p">)</span>

        <span class="n">transitions</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;transitions&#39;</span><span class="p">)</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_fa_transitions</span><span class="p">(</span><span class="n">transitions</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;transitions&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ET</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">etree_root</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_json_to_xml_pda</span><span class="p">(</span><span class="n">json_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Responsible for converting dictionaries representing push-down automata (DPDA, NPDA) to XML files</span>

<span class="sd">        :param json_dict: dictionary representation of a JSON structure describing push-down automaton</span>

<span class="sd">        :return: string representation of an XML file describing given push-down automaton</span>

<span class="sd">        :raises KeyError: when JSON dict has wrong structure</span>
<span class="sd">        :raises TypeError: when there are wrong types of values in JSON dict (input, push and pop symbols must be Characters), \</span>
<span class="sd">        or when JSON dict has wrong structure</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">etree_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>

        <span class="n">states</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;states&#39;</span><span class="p">)</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">],</span> <span class="s2">&quot;String&quot;</span><span class="p">)</span>

        <span class="n">input_alphabet</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;inputAlphabet&#39;</span><span class="p">)</span>
        <span class="n">children_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;input_alphabet&#39;</span><span class="p">]]</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">input_alphabet</span><span class="p">,</span> <span class="n">children_list</span><span class="p">,</span> <span class="s2">&quot;Character&quot;</span><span class="p">)</span>

        <span class="n">pushdown_store_alphabet</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;pushdownStoreAlphabet&#39;</span><span class="p">)</span>
        <span class="n">children_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;pushdown_store_alphabet&#39;</span><span class="p">]]</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">pushdown_store_alphabet</span><span class="p">,</span> <span class="n">children_list</span><span class="p">,</span> <span class="s2">&quot;Character&quot;</span><span class="p">)</span>

        <span class="n">initial_states</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;initialState&#39;</span><span class="p">)</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">initial_states</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;initial_states&#39;</span><span class="p">],</span> <span class="s2">&quot;String&quot;</span><span class="p">)</span>

        <span class="n">initial_pushdown_store_symbol</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;initialPushdownStoreSymbol&#39;</span><span class="p">)</span>
        <span class="n">child</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;initial_pushdown_store_symbol&#39;</span><span class="p">]))</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_single_subelement</span><span class="p">(</span><span class="n">initial_pushdown_store_symbol</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="s1">&#39;Character&#39;</span><span class="p">)</span>

        <span class="n">final_states</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;finalStates&#39;</span><span class="p">)</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">final_states</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;final_states&#39;</span><span class="p">],</span> <span class="s2">&quot;String&quot;</span><span class="p">)</span>

        <span class="n">transitions</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;transitions&#39;</span><span class="p">)</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_pda_transitions</span><span class="p">(</span><span class="n">transitions</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;transitions&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ET</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">etree_root</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_json_to_xml_grammar</span><span class="p">(</span><span class="n">json_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Responsible for converting dictionaries representing grammars (RightRG, CFG, CNF) to XML files</span>

<span class="sd">        :param json_dict: dictionary representation of a JSON structure describing grammar</span>

<span class="sd">        :return: string representation of an XML file describing given grammar</span>

<span class="sd">        :raises KeyError: when JSON dict has wrong structure</span>
<span class="sd">        :raises TypeError: when there are wrong types of values in JSON dict (terminal symbols must be Characters), \</span>
<span class="sd">        or when JSON dict has wrong structure</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g_type</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
        <span class="n">etree_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="n">g_type</span><span class="p">)</span>

        <span class="n">nonterminal_alphabet</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;nonterminalAlphabet&#39;</span><span class="p">)</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">nonterminal_alphabet</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;nonterminal_alphabet&#39;</span><span class="p">],</span> <span class="s2">&quot;String&quot;</span><span class="p">)</span>

        <span class="n">terminal_alphabet</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;terminalAlphabet&#39;</span><span class="p">)</span>
        <span class="n">children_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;terminal_alphabet&#39;</span><span class="p">]]</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">terminal_alphabet</span><span class="p">,</span> <span class="n">children_list</span><span class="p">,</span> <span class="s2">&quot;Character&quot;</span><span class="p">)</span>

        <span class="n">initial_symbol</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;initialSymbol&#39;</span><span class="p">)</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_single_subelement</span><span class="p">(</span><span class="n">initial_symbol</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;initial_symbol&#39;</span><span class="p">],</span> <span class="s2">&quot;String&quot;</span><span class="p">)</span>

        <span class="n">rules</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;rules&#39;</span><span class="p">)</span>
        <span class="n">allow_epsilon</span> <span class="o">=</span> <span class="n">g_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">CFG</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_grammar_rules</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;rules&#39;</span><span class="p">],</span> <span class="n">json_dict</span><span class="p">[</span><span class="s2">&quot;nonterminal_alphabet&quot;</span><span class="p">],</span> <span class="n">allow_epsilon</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;initial_symbol&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">g_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">RG</span> <span class="ow">or</span> <span class="n">g_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">CNF</span><span class="p">:</span>
            <span class="n">generates_epsilon</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;generatesEpsilon&#39;</span><span class="p">)</span>
            <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_grammar_generates_epsilon</span><span class="p">(</span><span class="n">generates_epsilon</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;rules&#39;</span><span class="p">],</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;initial_symbol&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ET</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">etree_root</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_json_to_xml_regexp</span><span class="p">(</span><span class="n">json_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Responsible for converting dictionaries representing regular expressions (UnboundedRegExp) to XML files</span>

<span class="sd">        :param json_dict: dictionary representation of a JSON structure describing regular expression</span>

<span class="sd">        :return: string representation of an XML file describing given regular expression</span>

<span class="sd">        :raises KeyError: when JSON dict has wrong structure</span>
<span class="sd">        :raises TypeError: when there are wrong types of values in JSON dict (alphabet symbols must be Characters), \</span>
<span class="sd">        or when JSON dict has wrong structure</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">etree_root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">(</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>

        <span class="n">alphabet</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="s1">&#39;alphabet&#39;</span><span class="p">)</span>
        <span class="n">children_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;alphabet&#39;</span><span class="p">]]</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_list_subelements</span><span class="p">(</span><span class="n">alphabet</span><span class="p">,</span> <span class="n">children_list</span><span class="p">,</span> <span class="s1">&#39;Character&#39;</span><span class="p">)</span>
        <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_create_regexp_value</span><span class="p">(</span><span class="n">etree_root</span><span class="p">,</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ET</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">etree_root</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="JtXConverter.simple_json_to_xml"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.JtXConverter.simple_json_to_xml">[docs]</a>    <span class="k">def</span> <span class="nf">simple_json_to_xml</span><span class="p">(</span><span class="n">json_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Base mathod of the class, takes dictionary representation of an JSON file,</span>
<span class="sd">        and converts it to an XML string</span>

<span class="sd">        :param json_dict: dictionary representation of an JSON file</span>

<span class="sd">        :return: string representation of an XML file that was converted from given JSON</span>

<span class="sd">        :raises KeyError: when JSON dict has wrong structure - the &#39;type&#39; property is not present</span>
<span class="sd">        :raises TypeError: when there is unknown object type</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj_type</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">DFA</span> <span class="ow">or</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">NFA</span> <span class="ow">or</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">EpsilonNFA</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_json_to_xml_fa</span><span class="p">(</span><span class="n">json_dict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">RG</span> <span class="ow">or</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">CFG</span> <span class="ow">or</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">CNF</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_json_to_xml_grammar</span><span class="p">(</span><span class="n">json_dict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">RegExp</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_json_to_xml_regexp</span><span class="p">(</span><span class="n">json_dict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">DPDA</span> <span class="ow">or</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">NPDA</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_json_to_xml_pda</span><span class="p">(</span><span class="n">json_dict</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>
        <span class="k">return</span> <span class="n">XML_VERSION</span> <span class="o">+</span> <span class="n">res</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_object_type</span><span class="p">(</span><span class="n">o_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Translates various object types to one of: &#39;rg&#39; | &#39;fa&#39; | &#39;re&#39; | &#39;cfg&#39; | &#39;pda&#39;</span>

<span class="sd">        :param o_type: object type</span>

<span class="sd">        :return: string representation of simple object type</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">o_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">RG</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;rg&#39;</span>
        <span class="k">elif</span> <span class="n">o_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">DFA</span> <span class="ow">or</span> <span class="n">o_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">NFA</span> <span class="ow">or</span> <span class="n">o_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">EpsilonNFA</span> <span class="ow">or</span> <span class="n">o_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">MultiNFA</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;fa&#39;</span>
        <span class="k">elif</span> <span class="n">o_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">RegExp</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;re&#39;</span>
        <span class="k">elif</span> <span class="n">o_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">CNF</span> <span class="ow">or</span> <span class="n">o_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">CFG</span> <span class="ow">or</span> <span class="n">o_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">EpsilonFreeCFG</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;cfg&#39;</span>
        <span class="k">elif</span> <span class="n">o_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">DPDA</span> <span class="ow">or</span> <span class="n">o_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">NPDA</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;pda&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>


    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="JtXConverter.comparison_json_to_xml"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.JtXConverter.comparison_json_to_xml">[docs]</a>    <span class="k">def</span> <span class="nf">comparison_json_to_xml</span><span class="p">(</span><span class="n">json_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Takes dictionary representation of an JSON file describing comparison</span>
<span class="sd">        and returns XML representations of structures to be compared and their simple types.</span>
<span class="sd">        Types are: &#39;rg&#39; | &#39;fa&#39; | &#39;re&#39; | &#39;cfg&#39; | &#39;pda&#39;.</span>

<span class="sd">        :param json_dict: dictionary representation of an JSON file</span>

<span class="sd">        :return: tuple of string representations of (XML file, its object type, XML file, its object type)</span>

<span class="sd">        :raises KeyError: when JSON dict has wrong structure</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">obj1</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;lhs&#39;</span><span class="p">]</span>
        <span class="n">obj2</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;rhs&#39;</span><span class="p">]</span>

        <span class="n">o_type_res1</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_get_object_type</span><span class="p">(</span><span class="n">obj1</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>
        <span class="n">o_type_res2</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_get_object_type</span><span class="p">(</span><span class="n">obj2</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>

        <span class="n">res1</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">simple_json_to_xml</span><span class="p">(</span><span class="n">obj1</span><span class="p">)</span>
        <span class="n">res2</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">simple_json_to_xml</span><span class="p">(</span><span class="n">obj2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res1</span><span class="p">,</span> <span class="n">o_type_res1</span><span class="p">,</span> <span class="n">res2</span><span class="p">,</span> <span class="n">o_type_res2</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="JtXConverter.transformation_json_to_xml"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.JtXConverter.transformation_json_to_xml">[docs]</a>    <span class="k">def</span> <span class="nf">transformation_json_to_xml</span><span class="p">(</span><span class="n">json_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Takes dictionary representation of an JSON file describing transformation</span>
<span class="sd">        and returns transformation source in XML string, its type and transformation target type.</span>
<span class="sd">        Types are: &#39;rg&#39; | &#39;fa&#39; | &#39;re&#39; | &#39;cfg&#39; | &#39;pda&#39;.</span>

<span class="sd">        :param json_dict: dictionary representation of an JSON file</span>

<span class="sd">        :return: tuple of string representations of (XML file - transformation source, source type, target type)</span>
<span class="sd">        :raises KeyError: when JSON dict has wrong structure</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">target_type</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">]</span>
        <span class="n">source_type</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">_get_object_type</span><span class="p">(</span><span class="n">source</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">simple_json_to_xml</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">source_type</span><span class="p">,</span> <span class="n">target_type</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="JtXConverter.derivation_json_to_xml"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.JtXConverter.derivation_json_to_xml">[docs]</a>    <span class="k">def</span> <span class="nf">derivation_json_to_xml</span><span class="p">(</span><span class="n">json_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Takes dictionary representation of an JSON file describing derivation</span>
<span class="sd">        and returns drivation string and derived regexp as XML string</span>

<span class="sd">        :param json_dict: dictionary representation of an JSON file</span>

<span class="sd">        :return: tuple of derivation string and string XML representation of the derived regular expression</span>

<span class="sd">        :raises KeyError: when JSON dict has wrong structure</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">simple_json_to_xml</span><span class="p">(</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;regexp&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;derivation_string&#39;</span><span class="p">],</span> <span class="n">res</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="JtXConverter.cyk_json_to_xml"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.JtXConverter.cyk_json_to_xml">[docs]</a>    <span class="k">def</span> <span class="nf">cyk_json_to_xml</span><span class="p">(</span><span class="n">json_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Takes dictionary representation of an JSON file describing CYK input</span>
<span class="sd">        and returns generated string and the grammar to be checked as XML string</span>

<span class="sd">        :param json_dict: dictionary representation of an JSON file</span>

<span class="sd">        :return: tuple of generated string and string XML representation of the grammar</span>

<span class="sd">        :raises KeyError: when JSON dict has wrong structure</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">simple_json_to_xml</span><span class="p">(</span><span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;grammar&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">json_dict</span><span class="p">[</span><span class="s1">&#39;generated_string&#39;</span><span class="p">],</span> <span class="n">res</span></div></div>

<span class="c1"># ----------------------------------------------------------------------------------------------------------------------</span>


<div class="viewcode-block" id="XtJConverter"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.XtJConverter">[docs]</a><span class="k">class</span> <span class="nc">XtJConverter</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Base class responsible for converting string representation of an XML structure</span>
<span class="sd">    to a string representation of an JSON structure.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_flatten_child_text</span><span class="p">(</span><span class="n">child</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">allow_name_change</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Takes child element, that has some sub elements and returns aggregated text value of the whole group</span>

<span class="sd">        :param child: element to be flattened to a string value</span>
<span class="sd">        :param referenced_values: list of already found references</span>
<span class="sd">        :param allow_name_change: boolean parameter that states if the name value from XML file can be changed</span>

<span class="sd">        :return: text representation of the element</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">subelement</span> <span class="ow">in</span> <span class="n">child</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_get_child_text</span><span class="p">(</span><span class="n">subelement</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">,</span>
                                                <span class="n">allow_name_change</span><span class="p">,</span> <span class="n">integer_in_string</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">text</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_child_text</span><span class="p">(</span><span class="n">child</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                        <span class="n">allow_name_change</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">integer_in_string</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Return text attribute of given element formatted according to the element given.</span>
<span class="sd">        Is able to fill in correct referenced values, create new values from pairs and sets</span>
<span class="sd">        and add new values to reference list.</span>

<span class="sd">        :param child: element we want to get text attribute from, must have tags Ref, String, Character, Integer or Pair</span>
<span class="sd">        :param referenced_values: list of already found references</span>
<span class="sd">        :param allow_name_change: boolean parameter that states if the name value from XML file can be changed</span>
<span class="sd">        :param integer_in_string: boolean parameter that states if the resulting value will be part of a string, \</span>
<span class="sd">        by default set to false</span>

<span class="sd">        :return: text representation od the element</span>

<span class="sd">        :raises KeyError: in case of wrong structure of the XML file - not present attributes, bad references</span>
<span class="sd">        :raises TypeError: when unknown tag occurs</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;Ref&quot;</span><span class="p">:</span>
            <span class="n">child_id</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">referenced_values</span><span class="p">[</span><span class="n">child_id</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;String&quot;</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">text</span>
        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;Character&quot;</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">text</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;Integer&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">allow_name_change</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">integer_in_string</span><span class="p">:</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">text</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">text</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">text</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">text</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">text</span>
        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;epsilon&quot;</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;Set&quot;</span> <span class="ow">or</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;Pair&quot;</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_flatten_child_text</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">,</span> <span class="n">allow_name_change</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;FinalStateLabel&quot;</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Final&quot;</span>
        <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;InitialSymbol&quot;</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;Start&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>

        <span class="k">if</span> <span class="s1">&#39;ref&#39;</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">allow_name_change</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">referenced_values</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">text</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span>
            <span class="n">referenced_values</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s1">&#39;ref&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">text</span>

        <span class="k">return</span> <span class="n">text</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_string_from_subelement</span><span class="p">(</span><span class="n">root_element</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">parent_tag</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                                       <span class="n">allow_name_change</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Creates one single string value from the first child of element with given parent tag.</span>
<span class="sd">        Accesses given root element, finds the first element with given parent tag, finds its first child element</span>
<span class="sd">        and returns its string representation. If the parent element has no children, returns None.</span>

<span class="sd">        :param root_element: parent element of the element, whose child&#39;s text is wanted</span>
<span class="sd">        :param parent_tag: tag of the element, whose child&#39;s text is wanted</span>
<span class="sd">        :param referenced_values: list of already found references</span>
<span class="sd">        :param allow_name_change: boolean parameter that states if the name value from XML file can be changed, \</span>
<span class="sd">        by default set to false</span>

<span class="sd">        :return: string representation of the child attribute, None if no child is present</span>

<span class="sd">        :raises IndexError: in case of wrong structure of the XML file - parent_tag is not present in the roots children</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent_element</span> <span class="o">=</span> <span class="n">root_element</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">parent_tag</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent_element</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">parent_element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_get_child_text</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">,</span> <span class="n">allow_name_change</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_list_from_subelements</span><span class="p">(</span><span class="n">root_element</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">parent_tag</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                                      <span class="n">allow_name_change</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Creates list of string values from all children of element with given parent tag.</span>
<span class="sd">        Accesses given root element, finds the first element with given parent tag, finds all its child elements</span>
<span class="sd">        and returns their string representations in a list.</span>

<span class="sd">        :param root_element: parent element of the element, whose children&#39;s text is wanted</span>
<span class="sd">        :param parent_tag: tag of the element, whose children&#39;s text is wanted</span>
<span class="sd">        :param referenced_values: list of already found references</span>
<span class="sd">        :param allow_name_change: boolean parameter that states if the name value from XML file can be changed, \</span>
<span class="sd">        by default set to false</span>

<span class="sd">        :return: list of string representations of the child attributes</span>

<span class="sd">        :raises IndexError: in case of wrong structure of the XML file - parent_tag is not present in the roots children</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent_element</span> <span class="o">=</span> <span class="n">root_element</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="n">parent_tag</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent_element</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_get_child_text</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">,</span> <span class="n">allow_name_change</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_list_fa_transitions</span><span class="p">(</span><span class="n">root_element</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Creates list of dictionaries, that represents finite automaton transitions.</span>
<span class="sd">        Format: [{&#39;from&#39;:, &#39;input&#39;:, &#39;to&#39;:}]</span>

<span class="sd">        :param root_element: element, which has child with the tag &#39;transitions&#39;</span>
<span class="sd">        :param referenced_values: list of already found references</span>

<span class="sd">        :return: list of dictionaries, that represents finite automaton transitions</span>

<span class="sd">        :raises IndexError: in case of wrong structure of the XML file - transitions tag is not present in the root</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent_element</span> <span class="o">=</span> <span class="n">root_element</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;transitions&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent_element</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;transition&#39;</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">t_from</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_string_from_subelement</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s1">&#39;from&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
            <span class="n">t</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_from</span>
            <span class="n">t_input</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_string_from_subelement</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
            <span class="n">t</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_input</span>
            <span class="n">t_to</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_string_from_subelement</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
            <span class="n">t</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_to</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_list_pda_transitions</span><span class="p">(</span><span class="n">root_element</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Creates list of dictionaries, that represents pushdown automaton transitions.</span>
<span class="sd">        Format: [{&#39;from&#39;:, &#39;input&#39;:, &#39;pop&#39;:, &#39;to&#39;:, &#39;push&#39;:}]</span>

<span class="sd">        :param root_element: element, which has child with the tag &#39;transitions&#39;</span>
<span class="sd">        :param referenced_values: list of already found references</span>

<span class="sd">        :return: list of dictionaries, that represents finite automaton transitions</span>

<span class="sd">        :raises IndexError: in case of wrong structure of the XML file - transitions tag is not present in the root</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent_element</span> <span class="o">=</span> <span class="n">root_element</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;transitions&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent_element</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;transition&#39;</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">t_from</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_string_from_subelement</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s1">&#39;from&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
            <span class="n">t</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_from</span>
            <span class="n">t_input</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_string_from_subelement</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
            <span class="n">t</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_input</span>
            <span class="n">t_pop</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s1">&#39;pop&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
            <span class="n">t</span><span class="p">[</span><span class="s1">&#39;pop&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_pop</span>
            <span class="n">t_to</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_string_from_subelement</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
            <span class="n">t</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_to</span>
            <span class="n">t_push</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s1">&#39;push&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
            <span class="n">t</span><span class="p">[</span><span class="s1">&#39;push&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_push</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_list_rules</span><span class="p">(</span><span class="n">root_element</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Creates list of dictionaries, that represents grammar rules.</span>
<span class="sd">        Format: [{&#39;from&#39;:, &#39;to&#39;:}]</span>

<span class="sd">        :param root_element: element, which has child with the tag &#39;rules&#39;</span>
<span class="sd">        :param referenced_values: list of already found references</span>

<span class="sd">        :return: list of dictionaries, that represents grammar rules</span>

<span class="sd">        :raises IndexError: in case of wrong structure of the XML file - rules tag is not present in the roots children</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parent_element</span> <span class="o">=</span> <span class="n">root_element</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;rules&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">parent_element</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;rule&#39;</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">r_lhs</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_string_from_subelement</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s1">&#39;lhs&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_lhs</span>
            <span class="n">r_rhs</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s1">&#39;rhs&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
            <span class="n">r</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_rhs</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_generates_epsilon</span><span class="p">(</span><span class="n">generates_epsilon</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">grammar_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Converts XML structure of generatesEpsilon to internal structure without it. Checks generatesEpsilon parameter</span>
<span class="sd">        value. If true, checks presence of initial symbol on the right side of grammar rules. Then eventually performs</span>
<span class="sd">        simple algorithm to remove rule &quot;rewrite initial symbol to epsilon&quot; while the initial symbol is present</span>
<span class="sd">        on the right side of some rules.</span>

<span class="sd">        :param generates_epsilon: boolean parameter that states, if the grammar given is able to rewrite initial \</span>
<span class="sd">        symbol to epsilon</span>
<span class="sd">        :param grammar_dict: dict representation of grammar</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">generates_epsilon</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">rules</span> <span class="o">=</span> <span class="n">grammar_dict</span><span class="p">[</span><span class="s1">&#39;rules&#39;</span><span class="p">]</span>                       <span class="c1"># pointer</span>
        <span class="n">initial_symbol</span> <span class="o">=</span> <span class="n">grammar_dict</span><span class="p">[</span><span class="s1">&#39;initial_symbol&#39;</span><span class="p">]</span>     <span class="c1"># value</span>

        <span class="c1"># is initial symbol present on the right side of any rule?</span>
        <span class="n">rules_with_initial_symbol</span> <span class="o">=</span> <span class="p">[</span><span class="n">rule</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span> <span class="k">if</span> <span class="n">initial_symbol</span> <span class="ow">in</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">]]</span>

        <span class="c1"># if not, append new rule of rewritting initial_symbol to epsilon and end</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rules_with_initial_symbol</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;from&#39;</span><span class="p">:</span> <span class="n">initial_symbol</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">:</span> <span class="p">[</span><span class="bp">None</span><span class="p">]})</span>
            <span class="k">return</span>

        <span class="c1"># if yes:</span>
        <span class="c1"># 1) add new initial symbol:</span>
        <span class="n">new_initial_symbol</span> <span class="o">=</span> <span class="n">initial_symbol</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">&quot;</span>
        <span class="k">while</span> <span class="n">new_initial_symbol</span> <span class="ow">in</span> <span class="n">grammar_dict</span><span class="p">[</span><span class="s1">&#39;nonterminal_alphabet&#39;</span><span class="p">]:</span>
            <span class="n">new_initial_symbol</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\&#39;</span><span class="s2">&quot;</span>
        <span class="n">grammar_dict</span><span class="p">[</span><span class="s1">&#39;nonterminal_alphabet&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_initial_symbol</span><span class="p">)</span>
        <span class="n">grammar_dict</span><span class="p">[</span><span class="s1">&#39;initial_symbol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_initial_symbol</span>
        <span class="c1"># 2) modified rules must be added, where initial_symbol is not present in them</span>
        <span class="n">modified_rules</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules_with_initial_symbol</span><span class="p">:</span>
            <span class="n">new_to</span> <span class="o">=</span> <span class="p">[</span><span class="n">symbol</span> <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">symbol</span> <span class="o">!=</span> <span class="n">initial_symbol</span><span class="p">]</span>
            <span class="n">modified_rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;from&#39;</span><span class="p">:</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">],</span> <span class="s1">&#39;to&#39;</span><span class="p">:</span> <span class="n">new_to</span><span class="p">})</span>
        <span class="c1"># add them only if they are not present yet and are not empty</span>
        <span class="n">rules_to_add</span> <span class="o">=</span> <span class="p">[</span><span class="n">rule</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">modified_rules</span> <span class="k">if</span> <span class="n">rule</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rules</span> <span class="ow">and</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]]</span>
        <span class="n">rules</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rules_to_add</span><span class="p">)</span>
        <span class="c1"># 3) rules from old initial symbol must be copied to the new one</span>
        <span class="n">rules_of_new_init</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;from&#39;</span><span class="p">:</span> <span class="n">new_initial_symbol</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">:</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;to&#39;</span><span class="p">]}</span> <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">rules</span> <span class="k">if</span> <span class="n">rule</span><span class="p">[</span><span class="s1">&#39;from&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">initial_symbol</span><span class="p">]</span>
        <span class="n">rules</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rules_of_new_init</span><span class="p">)</span>
        <span class="c1"># 4) add rewrite to epsilon to new initial symbol</span>
        <span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;from&#39;</span><span class="p">:</span> <span class="n">new_initial_symbol</span><span class="p">,</span> <span class="s1">&#39;to&#39;</span><span class="p">:</span> <span class="p">[</span><span class="bp">None</span><span class="p">]})</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_regexp_value</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Creates list-dictionary structure, that represents regular expression value.</span>
<span class="sd">        Method is supposed to be called recursively.</span>

<span class="sd">        :param element: element, which represents a valid regular expression</span>
<span class="sd">        :param referenced_values: list of already found references</span>

<span class="sd">        :return: list-dictionary structure, that represents regular expression value.</span>

<span class="sd">        :raises IndexError: in case of wrong structure of the XML file</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">e_tag</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">tag</span>
        <span class="k">if</span> <span class="n">e_tag</span> <span class="o">==</span> <span class="s1">&#39;epsilon&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;epsilon&#39;</span>
        <span class="k">elif</span> <span class="n">e_tag</span> <span class="o">==</span> <span class="s1">&#39;empty&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;empty_symbol&#39;</span>
        <span class="k">elif</span> <span class="n">e_tag</span> <span class="o">==</span> <span class="s1">&#39;iteration&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;iteration&#39;</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_regexp_value</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">referenced_values</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">e_tag</span> <span class="o">==</span> <span class="s1">&#39;concatenation&#39;</span> <span class="ow">or</span> <span class="n">e_tag</span> <span class="o">==</span> <span class="s1">&#39;alternation&#39;</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">e_tag</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">element</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_regexp_value</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
                <span class="n">value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;term&#39;</span>
            <span class="n">res</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_get_child_text</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">,</span> <span class="n">allow_name_change</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_xml_to_json_fa</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Converts given ElementTree structure to a dictionary, that can be turned into JSON file.</span>
<span class="sd">        ElementTree and dictionary both represent the same finite automaton.</span>

<span class="sd">        :param root: root element of ElementTree to be converted</span>

<span class="sd">        :return: dictionary representation of finite automaton</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">referenced_values</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">a_type</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span>
        <span class="k">if</span> <span class="n">a_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">MultiNFA</span><span class="p">:</span>
            <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">NFA</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_type</span>

        <span class="n">states</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;states&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">,</span> <span class="n">allow_name_change</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span>

        <span class="n">input_alphabet</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;inputAlphabet&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;input_alphabet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_alphabet</span>

        <span class="k">if</span> <span class="n">a_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">MultiNFA</span><span class="p">:</span>
            <span class="n">parent_tag</span> <span class="o">=</span> <span class="s2">&quot;initialStates&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parent_tag</span> <span class="o">=</span> <span class="s2">&quot;initialState&quot;</span>
        <span class="n">initial_states</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">parent_tag</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;initial_states&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_states</span>

        <span class="n">final_states</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;finalStates&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;final_states&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_states</span>

        <span class="n">transitions</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_fa_transitions</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;transitions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transitions</span>

        <span class="k">return</span> <span class="n">result_dict</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_xml_to_json_pda</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Converts given ElementTree structure to a dictionary, that can be turned into JSON file.</span>
<span class="sd">        ElementTree and dictionary both represent the same push-down automaton.</span>

<span class="sd">        :param root: root element of ElementTree to be converted</span>

<span class="sd">        :return: dictionary representation of push-down automaton</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">referenced_values</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">a_type</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_type</span>

        <span class="n">states</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;states&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">,</span> <span class="n">allow_name_change</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;states&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span>

        <span class="n">input_alphabet</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;inputAlphabet&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;input_alphabet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_alphabet</span>

        <span class="n">pd_store_alphabet</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;pushdownStoreAlphabet&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;pushdown_store_alphabet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd_store_alphabet</span>

        <span class="n">initial_states</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;initialState&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;initial_states&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_states</span>

        <span class="n">init_pd_symbol</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_string_from_subelement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;initialPushdownStoreSymbol&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;initial_pushdown_store_symbol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">init_pd_symbol</span>

        <span class="n">final_states</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;finalStates&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;final_states&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">final_states</span>

        <span class="n">transitions</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_pda_transitions</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;transitions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transitions</span>

        <span class="k">return</span> <span class="n">result_dict</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_xml_to_json_regexp</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Converts given ElementTree structure to a dictionary, that can be turned into JSON file.</span>
<span class="sd">        ElementTree and dictionary both represent the same regular expression.</span>

<span class="sd">        :param root: root element of ElementTree to be converted</span>

<span class="sd">        :return: dictionary representation of regular expression</span>

<span class="sd">        :raises IndexError: in case of wrong structure of the XML file - wrong number of root children</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">referenced_values</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">r_type</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_type</span>

        <span class="n">alphabet</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;alphabet&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;alphabet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">alphabet</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_regexp_value</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">result_dict</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_xml_to_json_grammar</span><span class="p">(</span><span class="n">root</span><span class="p">:</span> <span class="n">ET</span><span class="o">.</span><span class="n">Element</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Converts given ElementTree structure to a dictionary, that can be turned into JSON file.</span>
<span class="sd">        ElementTree and dictionary both represent the same grammar.</span>

<span class="sd">        :param root: root element of ElementTree to be converted</span>

<span class="sd">        :return: dictionary representation of grammar</span>

<span class="sd">        :raises IndexError: in case of wrong structure of the XML file - wrong appearance \</span>
<span class="sd">        and usage of generatesEpsilon tag</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">referenced_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">g_type</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span>
        <span class="k">if</span> <span class="n">g_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">EpsilonFreeCFG</span><span class="p">:</span>
            <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">CFG</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g_type</span>

        <span class="n">nonterminal_alphabet</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;nonterminalAlphabet&#39;</span><span class="p">,</span>
                                                                          <span class="n">referenced_values</span><span class="p">,</span> <span class="n">allow_name_change</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;nonterminal_alphabet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nonterminal_alphabet</span>

        <span class="n">terminal_alphabet</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_from_subelements</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;terminalAlphabet&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;terminal_alphabet&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">terminal_alphabet</span>

        <span class="n">initial_symbol</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_string_from_subelement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;initialSymbol&#39;</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;initial_symbol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_symbol</span>

        <span class="n">rules</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_list_rules</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">referenced_values</span><span class="p">)</span>
        <span class="n">result_dict</span><span class="p">[</span><span class="s1">&#39;rules&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rules</span>

        <span class="c1"># solve generates epsilon</span>
        <span class="k">if</span> <span class="n">g_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">RG</span> <span class="ow">or</span> <span class="n">g_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">CNF</span> <span class="ow">or</span> <span class="n">g_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">EpsilonFreeCFG</span><span class="p">:</span>
            <span class="n">generates_epsilon</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;generatesEpsilon&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s1">&#39;true&#39;</span>
            <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_create_generates_epsilon</span><span class="p">(</span><span class="n">generates_epsilon</span><span class="p">,</span> <span class="n">result_dict</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result_dict</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="XtJConverter.simple_xml_to_json"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.XtJConverter.simple_xml_to_json">[docs]</a>    <span class="k">def</span> <span class="nf">simple_xml_to_json</span><span class="p">(</span><span class="n">xml_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Converts given XML file to a dictionary, that can be turned into JSON file.</span>
<span class="sd">        Converts XML file to ElementTree structure, according to the parent tag of the structure</span>
<span class="sd">        chooses correct conversion method.</span>

<span class="sd">        :param xml_file: string representation of an xml file</span>

<span class="sd">        :return: dictionary that represents converted object</span>

<span class="sd">        :raises TypeError: when there is unknown object type</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">xml_file</span><span class="p">)</span>
        <span class="n">obj_type</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">tag</span>
        <span class="k">if</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">DFA</span> <span class="ow">or</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">NFA</span> <span class="ow">or</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">EpsilonNFA</span> <span class="ow">or</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">MultiNFA</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_xml_to_json_fa</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">RG</span> <span class="ow">or</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">CFG</span> <span class="ow">or</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">CNF</span> <span class="ow">or</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">EpsilonFreeCFG</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_xml_to_json_grammar</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">RegExp</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_xml_to_json_regexp</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">DPDA</span> <span class="ow">or</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ObjectTypes</span><span class="o">.</span><span class="n">NPDA</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">_xml_to_json_pda</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span>

        <span class="k">return</span> <span class="n">result</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="XtJConverter.comparison_xml_to_json"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.XtJConverter.comparison_xml_to_json">[docs]</a>    <span class="k">def</span> <span class="nf">comparison_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Converts given result of a comparison to a dictionary, that can be converted to JSON</span>

<span class="sd">        :param result: result of a comparison, bool value</span>

<span class="sd">        :return: dictionary with the result, that can be converted to JSON</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;result&#39;</span><span class="p">:</span> <span class="n">result</span><span class="p">}</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="XtJConverter.derivation_xml_to_json"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.XtJConverter.derivation_xml_to_json">[docs]</a>    <span class="k">def</span> <span class="nf">derivation_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Converts given result of a derivation and its steps to a dictionary, that can be converted to JSON</span>

<span class="sd">        :param result: resulting RegExp of a derivation</span>
<span class="sd">        :param steps: list of RegExps that represents the steps of the derivation</span>

<span class="sd">        :return: dictionary representation of the result and the steps, can be converted to JSON</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;result&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">simple_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">r_steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">steps</span><span class="p">:</span>
            <span class="n">r_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">XtJConverter</span><span class="o">.</span><span class="n">simple_xml_to_json</span><span class="p">(</span><span class="n">step</span><span class="p">))</span>
        <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;steps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">r_steps</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="XtJConverter.cnf_leftrec_xml_to_json"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.XtJConverter.cnf_leftrec_xml_to_json">[docs]</a>    <span class="k">def</span> <span class="nf">cnf_leftrec_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Converts given result of a conversion to CNF or left recursion removal and its steps to a dictionary,</span>
<span class="sd">        that can be converted to JSON</span>

<span class="sd">        :param result: resulting grammar of the algorithm</span>
<span class="sd">        :param steps: list of grammars that represents the steps of the algorithm</span>

<span class="sd">        :return: dictionary representation of the result and the steps, can be converted to JSON</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;result&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">simple_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;after_reduction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">simple_xml_to_json</span><span class="p">(</span><span class="n">steps</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;after_epsilon&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">simple_xml_to_json</span><span class="p">(</span><span class="n">steps</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ret</span><span class="p">[</span><span class="s1">&#39;after_unit_rules&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">simple_xml_to_json</span><span class="p">(</span><span class="n">steps</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="XtJConverter.minimization_xml_to_json"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.XtJConverter.minimization_xml_to_json">[docs]</a>    <span class="k">def</span> <span class="nf">minimization_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="XtJConverter.cyk_xml_to_json"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.XtJConverter.cyk_xml_to_json">[docs]</a>    <span class="k">def</span> <span class="nf">cyk_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div></div>


<div class="viewcode-block" id="json_to_xml"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.json_to_xml">[docs]</a><span class="k">def</span> <span class="nf">json_to_xml</span><span class="p">(</span><span class="n">json_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Converts given JSON string representation to corresponding XML string representation</span>

<span class="sd">    :param json_file: string with JSON file to convert</span>
<span class="sd">    :param param: optional parameter describing JSON file structure - if it&#39;s simple, \</span>
<span class="sd">    or one of the special cases - comparison, transformation or derivation. \</span>
<span class="sd">    If it&#39;s not a special case, it can be omitted.</span>

<span class="sd">    :return: representation of a converted JSON file, usually XML string or tuple of XML strings and needed parameters</span>

<span class="sd">    :raises JSONDecodeError: in case of wrong structure of the JSON file</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">json_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">json_file</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">param</span> <span class="o">==</span> <span class="n">AlgorithmTypes</span><span class="o">.</span><span class="n">COMPARISON</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">comparison_json_to_xml</span><span class="p">(</span><span class="n">json_dict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="n">AlgorithmTypes</span><span class="o">.</span><span class="n">TRANSFORMATION</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">transformation_json_to_xml</span><span class="p">(</span><span class="n">json_dict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="n">AlgorithmTypes</span><span class="o">.</span><span class="n">REGEXP_DERIVATION</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">derivation_json_to_xml</span><span class="p">(</span><span class="n">json_dict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="n">AlgorithmTypes</span><span class="o">.</span><span class="n">GRAMMAR_CYK</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">cyk_json_to_xml</span><span class="p">(</span><span class="n">json_dict</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">JtXConverter</span><span class="o">.</span><span class="n">simple_json_to_xml</span><span class="p">(</span><span class="n">json_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">except</span> <span class="n">json</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">JSONDecodeError</span><span class="p">(</span><span class="s2">&quot;JSON decode exception&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">JSONDecodeError</span><span class="p">(</span><span class="s2">&quot;Invalid JSON structure&quot;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">JSONDecodeError</span><span class="p">(</span><span class="s2">&quot;Unexpected exception occurred&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="xml_to_json"><a class="viewcode-back" href="../../backend.html#backend.XMLConverter.xml_to_json">[docs]</a><span class="k">def</span> <span class="nf">xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Converts given algorithm result to corresponding JSON string representation</span>

<span class="sd">    :param result: algorithm result, can be string representing XML file or a bool value, according to param attribute</span>
<span class="sd">    :param param: optional parameter describing result structure. If it&#39;s one of the special cases - derivation, \</span>
<span class="sd">    comparison, minimization, cnf conversion, left recursion removal or cyk algorithm -  it must be present. \</span>
<span class="sd">    If it&#39;s not a special case, it can be omitted.</span>
<span class="sd">    :param steps: optional parameter describing steps of the algorithm. Either a string or a list of strings, \</span>
<span class="sd">    according to the param specified. May be present with derivation, minimization or cyk. Must be present with \</span>
<span class="sd">    cnf conversion and left recursion removal.</span>

<span class="sd">    :return: string representation of a JSON file</span>

<span class="sd">    :raises XMLDEcodeError: in case of wrong structure of the XML file</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">param</span> <span class="o">==</span> <span class="n">AlgorithmTypes</span><span class="o">.</span><span class="n">COMPARISON</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">comparison_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="n">AlgorithmTypes</span><span class="o">.</span><span class="n">AUTOMATON_MINIMIZATION</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">minimization_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="n">AlgorithmTypes</span><span class="o">.</span><span class="n">REGEXP_DERIVATION</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">derivation_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="n">AlgorithmTypes</span><span class="o">.</span><span class="n">GRAMMAR_CNF_CONVERSION</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">cnf_leftrec_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="n">AlgorithmTypes</span><span class="o">.</span><span class="n">GRAMMAR_LEFT_RECURSION_REMOVAL</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">cnf_leftrec_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">param</span> <span class="o">==</span> <span class="n">AlgorithmTypes</span><span class="o">.</span><span class="n">GRAMMAR_CYK</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">cyk_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">XtJConverter</span><span class="o">.</span><span class="n">simple_xml_to_json</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">ET</span><span class="o">.</span><span class="n">ParseError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">XMLDecodeError</span><span class="p">(</span><span class="s2">&quot;XML parse exception&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">XMLDecodeError</span><span class="p">(</span><span class="s2">&quot;Invalid XML structure&quot;</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">XMLDecodeError</span><span class="p">(</span><span class="s2">&quot;Unexpected exception occurred&quot;</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../backend.html">backend</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Author.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
    </div>

    

    
  </body>
</html>